#!bin/python

"""
now launches like this:
% bin/curvecalc http://light9.bigasterisk.com/show/dance2007/song1



todo: curveview should preserve more objects, for speed maybe

"""
from __future__ import division
import time,textwrap,os,optparse, urllib2
import Tix as tk
import louie as dispatcher 
from twisted.internet import reactor,tksupport

from rdflib import URIRef
from rdflib import Graph
import rdflib
import logging
log = logging.getLogger()

import run_local
from light9 import showconfig, prof
from light9.curvecalc.zoomcontrol import Zoomcontrol
from light9.curvecalc.curve import Curveset
from light9.curvecalc.curveview import Curvesetview
from light9.curvecalc.musicaccess import Music, currentlyPlayingSong
from light9.wavelength import wavelength
from light9.uihelpers import toplevelat
from light9.namespaces import L9
from light9.curvecalc.subterm import read_all_subs, savekey, graphPathForSubterms
from light9.curvecalc.subtermview import makeSubtermCommandRow, add_one_subterm
from light9.curvecalc.output import Output

def makeStatusLines(master):
    """various labels that listen for dispatcher signals"""
    for signame,textfilter in [
        ('input time',lambda t: "%.2fs"%t),
        ('output levels',
         lambda levels: textwrap.fill("; ".join(["%s:%.2f"%(n,v)
                                                 for n,v in
                                                 levels.items()[:5]
                                                 if v>0]),70)),
        ('update period',lambda t: "%.1fms"%(t*1000)),
        ('update status',lambda t: str(t)),
        ]:
        l = tk.Label(master, anchor='w', justify='left', text='%s:' % signame)
        l.pack(side='top',fill='x')
        dispatcher.connect(lambda val,l=l,sn=signame,tf=textfilter:
                           l.config(text=sn+": "+tf(val)),
                           signame, weak=False)

def add_subterms_for_song(graph, song, curveset, subterms, master):
    for st in graph.objects(song, L9['subterm']):
        log.info("song %s has subterm %s", song, st)
        try:
            add_one_subterm(graph, graph.value(st, L9['sub']), curveset,
                            subterms, master, graph.value(st, L9['expression']))
        except rdflib.exceptions.UniquenessError:
            print "working around curvecalc save corruption"
            # curvecalc put all the expressions on one subterm, which is wrong
            for expr in graph.objects(st, L9['expression']):
                add_one_subterm(graph, graph.value(st, L9['sub']),
                                curveset, subterms, master, expr)
                

def makeGraph():
    graphOrig = showconfig.getGraph()
    graph = Graph() # a copy, since we're going to add subs into it
    for s in graphOrig:
        graph.add(s)
    read_all_subs(graph)
    return graph

def setupKeyBindings(root, song, subterms, curveset):
    root.bind("<Control-Key-s>",
              lambda *args: savekey(song, subterms, curveset))
    root.bind("<Control-Key-r>", lambda evt: dispatcher.send('reload all subs'))
    root.bind("<Control-Key-n>",
              lambda evt: dispatcher.send('focus new subterm'))
    root.bind("<Control-Key-N>", lambda evt: dispatcher.send('focus new curve'))
    root.bind("<Control-Key-q>",lambda ev: reactor.stop)
    root.bind("<Destroy>",lambda ev: reactor.stop)
    root.protocol('WM_DELETE_WINDOW', reactor.stop)

def setupMenubar(barFrame, root, song, subterms, curveset):
    class newMenu(object):
        def __init__(self, name):
            self.name = name
        def __enter__(self):
            m = tk.Menubutton(barFrame, text=self.name)
            m.pack(side='left')
            mm = tk.Menu(m)
            m.config(menu=mm)
            return mm
        def __exit__(self, type, value, traceback):
            return False
        
    def notImpl(*args):
        print "sorry, menu command binding isn't done yet. Use the keyboard shortcut"
        
    with newMenu("Curvecalc") as m:
        m.add_command(label='Save', underline=0, accelerator="Ctrl+s",
                      command=lambda *args: savekey(song, subterms, curveset))
        m.add_command(label='Quit', command=root.destroy)

    with newMenu("View") as m:
        m.add_command(label="See current time", accelerator="Esc", command=notImpl)
        m.add_command(label="See from current time -> end", accelerator="Shift+Esc", command=notImpl)
        m.add_command(label="Zoom all", accelerator="Ctrl+Esc", command=notImpl)
        m.add_command(label="Zoom in", accelerator="Wheel up", command=notImpl)
        m.add_command(label="Zoom out", accelerator="Wheel down", command=notImpl)

    with newMenu("Playback") as m:
        m.add_command(label="Play/pause at mouse", accelerator="Ctrl+P", command=notImpl)

    with newMenu("Points") as m:
        m.add_command(label="Delete", accelerator="Del", command=notImpl)


def createHelpLines(root):
    for helpline in ["Mousewheel zoom; C-p play/pause music at mouse",
                     "Curve point bindings: B1 drag point; C-B1 curve add point; S-B1 sketch points; 1..5 add point at time; B1 drag select points",
                     "Available in functions: nsin/ncos period=amp=1; within(a,b) bef(x) aft(x) compare to time; smoove(x) cubic smoothstep; chan(name); curvename(t) eval curve"]:
        line = tk.Label(root, text=helpline, font="Helvetica -12 italic",
                        anchor='w')
        line.pack(side='top',fill='x')

def main():
    startTime = time.time()
    parser = optparse.OptionParser()
    parser.set_usage("%prog [opts] [songURI]")
    parser.add_option("--sliders", action='store_true',
                      help='use hardware sliders')
    parser.add_option("--skip-music", action='store_true',
                      help="ignore music and smooth_music curve files")
    parser.add_option("--debug", action="store_true",
                      help="log at DEBUG")
    parser.add_option("--startup-only", action='store_true',
                      help="quit after loading everything (for timing tests)")
    opts, args = parser.parse_args()

    logging.basicConfig(format="%(asctime)s %(levelname)-5s %(name)s %(filename)s:%(lineno)d: %(message)s")
    log.setLevel(logging.DEBUG if opts.debug else logging.INFO)

    log.debug("startup: music %s", time.time() - startTime)
    try:
        song = URIRef(args[0])
    except IndexError:
        song = currentlyPlayingSong()

    music=Music()
    graph = makeGraph()
    curveset = Curveset(sliders=opts.sliders)
    subterms = []

    subtermPath = graphPathForSubterms(song)
    try:
        graph.parse(subtermPath, format='n3')
    except urllib2.URLError, e:
        if e.reason.errno != 2:
            raise
        log.info("%s not found, starting with empty graph" % subtermPath)
    
    log.debug("startup: output %s", time.time() - startTime)
    out = Output(subterms, music)

    musicfilename = showconfig.songOnDisk(song)
    maxtime = wavelength(musicfilename)
    dispatcher.connect(lambda: maxtime, "get max time", weak=False)


    root=tk.Tk()
    root.tk_setPalette("gray50")
    toplevelat("curvecalc",root)
    root.tk_focusFollowsMouse()
    root.title("curvecalc - %s" % graph.label(song))

    menubar = tk.Frame(root)
    menubar.pack(side='top', fill='x')

    if 'fixed top rows':
        zc = Zoomcontrol(root)
        zc.pack(side='top', fill='x')

    if 'panes':
        panes = tk.PanedWindow(root, height=1)
        panes.add('curvesetView')
        panes.add('subterms')
        panes.pack(side='top', fill='both', expand=True)

        curvesetView = Curvesetview(panes.subwidget('curvesetView'), curveset,
                                    height=600)
        curvesetView.pack(fill='both', expand=True)

        subtermArea = tk.Frame(panes.subwidget('subterms'), height=100)
        subtermArea.pack(fill='both', expand=True)

        subtermScroll = tk.ScrolledWindow(subtermArea)
        subtermScroll.pack(fill='both')

    if 'fixed bottom rows':
        makeSubtermCommandRow(root, curveset, subterms, root, subtermArea,
                              graph).pack(side='top', fill='x')
        makeStatusLines(root)

        helpBox = tk.Frame(root)
        createHelpLines(helpBox)
        helpBox.pack(side='top', fill='x')

    add_subterms_for_song(graph, song, curveset, subterms,
                          subtermScroll.subwidget('window'))
    setupKeyBindings(root, song, subterms, curveset)
    setupMenubar(menubar, root, song, subterms, curveset)

    # curvesetview must already exist, since this makes 'add_curve'
    # signals for all the initial curves
    curveset.load(basename=os.path.join(showconfig.curvesDir(),
                                        showconfig.songFilenameFromURI(song)),
                  skipMusic=opts.skip_music)
    
    dispatcher.send("max time",maxtime=maxtime)
    dispatcher.send("show all")
    
    # this is scheduled after some tk shuffling, to try to minimize
    # the number of times we redraw the curve at startup. If tk is
    # very slow, it's ok. You'll just get some wasted redraws.
    reactor.callLater(.1, curvesetView.goLive)

    tksupport.install(root, ms=10)
    log.debug("startup: run %s", time.time() - startTime)
    if opts.startup_only:
        log.debug("quitting now because of --startup-only")
        return
    prof.run(reactor.run, profile=False)

main()
